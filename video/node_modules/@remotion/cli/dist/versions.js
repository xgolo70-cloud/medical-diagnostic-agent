"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.versionsCommand = exports.validateVersionsBeforeCommand = exports.VERSIONS_COMMAND = void 0;
const renderer_1 = require("@remotion/renderer");
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const chalk_1 = require("./chalk");
const extra_packages_1 = require("./extra-packages");
const list_of_remotion_packages_1 = require("./list-of-remotion-packages");
const log_1 = require("./log");
const parse_command_line_1 = require("./parse-command-line");
const resolve_from_1 = require("./resolve-from");
const getVersion = async (remotionRoot, p) => {
    try {
        const remotionPkgJson = (0, resolve_from_1.resolveFrom)(remotionRoot, `${p}/package.json`);
        const file = await node_fs_1.default.promises.readFile(remotionPkgJson, 'utf-8');
        const packageJson = JSON.parse(file);
        return { version: packageJson.version, path: remotionPkgJson };
    }
    catch (_a) {
        return null;
    }
};
const groupBy = (vals) => {
    const groups = {};
    for (const [pkg, version] of vals) {
        if (!groups[version.version]) {
            groups[version.version] = [];
        }
        groups[version.version].push({
            pkg,
            versionAndPath: version,
        });
    }
    return groups;
};
const getAllVersions = async (remotionRoot) => {
    return (await Promise.all(list_of_remotion_packages_1.listOfRemotionPackages.map(async (p) => [p, await getVersion(remotionRoot, p)]))).filter(([, version]) => version);
};
const getExtraPackagesStatus = async (remotionRoot) => {
    const results = [];
    for (const [pkg, requiredVersion] of Object.entries(extra_packages_1.EXTRA_PACKAGES)) {
        const versionAndPath = await getVersion(remotionRoot, pkg);
        if (versionAndPath) {
            results.push({
                pkg,
                requiredVersion,
                installedVersion: versionAndPath.version,
                path: versionAndPath.path,
                isCorrect: versionAndPath.version === requiredVersion,
            });
        }
        else {
            results.push({
                pkg,
                requiredVersion,
                installedVersion: null,
                path: null,
                isCorrect: true, // Not installed is fine - only validate if installed
            });
        }
    }
    return results;
};
exports.VERSIONS_COMMAND = 'versions';
const validateVersionsBeforeCommand = async (remotionRoot, logLevel) => {
    var _a;
    const versions = await getAllVersions(remotionRoot);
    const grouped = groupBy(versions);
    const installedVersions = Object.keys(grouped);
    const hasRemotionMismatch = installedVersions.length > 1 && installedVersions.length !== 0;
    // Check extra packages
    const extraPackagesStatus = await getExtraPackagesStatus(remotionRoot);
    const incorrectExtraPackages = extraPackagesStatus.filter((status) => !status.isCorrect);
    if (!hasRemotionMismatch && incorrectExtraPackages.length === 0) {
        return;
    }
    // Could be a global install of @remotion/cli.
    // If you render a bundle with a different version, it will give a warning accordingly.
    if (installedVersions.length === 0 && incorrectExtraPackages.length === 0) {
        return;
    }
    const logOptions = { indent: false, logLevel };
    log_1.Log.warn(logOptions, '-------------');
    log_1.Log.warn(logOptions, 'Version mismatch:');
    if (hasRemotionMismatch) {
        for (const version of installedVersions) {
            log_1.Log.warn(logOptions, `- On version: ${version}`);
            for (const pkg of (_a = grouped[version]) !== null && _a !== void 0 ? _a : []) {
                log_1.Log.warn(logOptions, `  - ${pkg.pkg} ${chalk_1.chalk.gray(node_path_1.default.relative(remotionRoot, pkg.versionAndPath.path))}`);
            }
            log_1.Log.info({ indent: false, logLevel });
        }
    }
    if (incorrectExtraPackages.length > 0) {
        log_1.Log.warn(logOptions, 'Extra packages with wrong versions:');
        for (const status of incorrectExtraPackages) {
            const docLink = extra_packages_1.EXTRA_PACKAGES_DOCS[status.pkg];
            log_1.Log.warn(logOptions, `  - ${status.pkg}: installed ${status.installedVersion}, required ${status.requiredVersion}`);
            if (docLink) {
                log_1.Log.warn(logOptions, `    See: ${docLink}`);
            }
        }
        log_1.Log.info({ indent: false, logLevel });
    }
    log_1.Log.warn(logOptions, 'You may experience breakages such as:');
    log_1.Log.warn(logOptions, '- React context and hooks not working');
    log_1.Log.warn(logOptions, '- Type errors and feature incompatibilities');
    log_1.Log.warn(logOptions, '- Failed renders and unclear errors');
    log_1.Log.warn(logOptions);
    log_1.Log.warn(logOptions, 'To resolve:');
    log_1.Log.warn(logOptions, '- Make sure your package.json has all Remotion packages pointing to the same version.');
    log_1.Log.warn(logOptions, '- Remove the `^` character in front of a version to pin a package.');
    for (const incorrectPkg of incorrectExtraPackages) {
        log_1.Log.warn(logOptions, `- For ${incorrectPkg.pkg}, install exact version ${incorrectPkg.requiredVersion} (run: npx remotion add ${incorrectPkg.pkg}).`);
    }
    if (!renderer_1.RenderInternals.isEqualOrBelowLogLevel(logLevel, 'verbose')) {
        log_1.Log.warn(logOptions, '- Run `npx remotion versions --log=verbose` to see the path of the modules resolved.');
    }
    log_1.Log.warn(logOptions, '-------------');
    log_1.Log.info({ indent: false, logLevel });
};
exports.validateVersionsBeforeCommand = validateVersionsBeforeCommand;
const versionsCommand = async (remotionRoot, logLevel) => {
    var _a;
    (0, parse_command_line_1.parseCommandLine)();
    const versions = await getAllVersions(remotionRoot);
    const grouped = groupBy(versions);
    const installedVersions = Object.keys(grouped);
    log_1.Log.info({ indent: false, logLevel }, `Node.JS = ${process.version}, OS = ${process.platform}`);
    log_1.Log.info({ indent: false, logLevel });
    for (const version of installedVersions) {
        log_1.Log.info({ indent: false, logLevel }, `On version: ${version}`);
        for (const pkg of (_a = grouped[version]) !== null && _a !== void 0 ? _a : []) {
            log_1.Log.info({ indent: false, logLevel }, `- ${pkg.pkg}`);
            log_1.Log.verbose({ indent: false, logLevel }, `  ${(0, resolve_from_1.resolveFrom)(remotionRoot, `${pkg.pkg}/package.json`)}`);
        }
        log_1.Log.info({ indent: false, logLevel });
    }
    // Check extra packages
    const extraPackagesStatus = await getExtraPackagesStatus(remotionRoot);
    const installedExtraPackages = extraPackagesStatus.filter((status) => status.installedVersion !== null);
    if (installedExtraPackages.length > 0) {
        log_1.Log.info({ indent: false, logLevel }, 'Extra packages:');
        for (const status of installedExtraPackages) {
            const versionStatus = status.isCorrect
                ? chalk_1.chalk.green(`${status.installedVersion}`)
                : chalk_1.chalk.red(`${status.installedVersion} (required: ${status.requiredVersion})`);
            log_1.Log.info({ indent: false, logLevel }, `- ${status.pkg}@${versionStatus}`);
            if (status.path) {
                log_1.Log.verbose({ indent: false, logLevel }, `  ${status.path}`);
            }
        }
        log_1.Log.info({ indent: false, logLevel });
    }
    if (installedVersions.length === 0) {
        log_1.Log.info({ indent: false, logLevel }, 'No Remotion packages found.');
        log_1.Log.info({ indent: false, logLevel }, 'Maybe @remotion/cli is installed globally.');
        log_1.Log.info({ indent: false, logLevel }, 'If you try to render a video that was bundled with a different version, you will get a warning.');
        process.exit(1);
    }
    const incorrectExtraPackages = extraPackagesStatus.filter((status) => !status.isCorrect);
    if (installedVersions.length === 1 && incorrectExtraPackages.length === 0) {
        log_1.Log.info({ indent: false, logLevel }, `All packages have the correct version.`);
    }
    else {
        if (installedVersions.length !== 1) {
            log_1.Log.error({ indent: false, logLevel }, 'Version mismatch: Not all Remotion packages have the same version.');
            log_1.Log.info({ indent: false, logLevel }, '- Make sure your package.json has all Remotion packages pointing to the same version.');
            log_1.Log.info({ indent: false, logLevel }, '- Remove the `^` character in front of a version to pin a package.');
        }
        if (incorrectExtraPackages.length > 0) {
            log_1.Log.error({ indent: false, logLevel }, 'Extra packages have incorrect versions:');
            for (const status of incorrectExtraPackages) {
                const docLink = extra_packages_1.EXTRA_PACKAGES_DOCS[status.pkg];
                log_1.Log.info({ indent: false, logLevel }, `- ${status.pkg}: installed ${status.installedVersion}, required ${status.requiredVersion}`);
                if (docLink) {
                    log_1.Log.info({ indent: false, logLevel }, `  See: ${docLink}`);
                }
            }
            log_1.Log.info({ indent: false, logLevel }, `To fix, run: npx remotion add ${incorrectExtraPackages.map((s) => s.pkg).join(' ')}`);
        }
        if (!renderer_1.RenderInternals.isEqualOrBelowLogLevel(logLevel, 'verbose')) {
            log_1.Log.info({ indent: false, logLevel }, '- Rerun this command with --log=verbose to see the path of the modules resolved.');
        }
        process.exit(1);
    }
};
exports.versionsCommand = versionsCommand;
