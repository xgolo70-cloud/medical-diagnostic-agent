"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCommand = void 0;
const renderer_1 = require("@remotion/renderer");
const studio_server_1 = require("@remotion/studio-server");
const node_child_process_1 = require("node:child_process");
const node_fs_1 = __importDefault(require("node:fs"));
const chalk_1 = require("./chalk");
const extra_packages_1 = require("./extra-packages");
const list_of_remotion_packages_1 = require("./list-of-remotion-packages");
const log_1 = require("./log");
const resolve_from_1 = require("./resolve-from");
const getInstalledVersion = (remotionRoot, pkg) => {
    try {
        const pkgJsonPath = (0, resolve_from_1.resolveFrom)(remotionRoot, `${pkg}/package.json`);
        const file = node_fs_1.default.readFileSync(pkgJsonPath, 'utf-8');
        const packageJson = JSON.parse(file);
        return packageJson.version;
    }
    catch (_a) {
        return null;
    }
};
const addCommand = async ({ remotionRoot, packageManager, packageNames, logLevel, args, }) => {
    // Validate that all package names are Remotion packages
    const invalidPackages = packageNames.filter((pkg) => !list_of_remotion_packages_1.listOfRemotionPackages.includes(pkg) && !extra_packages_1.EXTRA_PACKAGES[pkg]);
    if (invalidPackages.length > 0) {
        throw new Error(`The following packages are not Remotion packages: ${invalidPackages.join(', ')}. Must be one of the Remotion packages or one of the supported extra packages: ${Object.keys(extra_packages_1.EXTRA_PACKAGES).join(', ')}.`);
    }
    const { dependencies, devDependencies, optionalDependencies, peerDependencies, } = studio_server_1.StudioServerInternals.getInstalledDependencies(remotionRoot);
    // Check if packages are already installed
    const allDeps = [
        ...dependencies,
        ...devDependencies,
        ...optionalDependencies,
        ...peerDependencies,
    ];
    const alreadyInstalled = [];
    const toInstall = [];
    const toUpgrade = [];
    for (const pkg of packageNames) {
        const isInstalled = allDeps.includes(pkg);
        const requiredVersion = extra_packages_1.EXTRA_PACKAGES[pkg];
        if (!isInstalled) {
            toInstall.push(pkg);
        }
        else if (requiredVersion) {
            // For extra packages, check if the version is correct
            const installedVersion = getInstalledVersion(remotionRoot, pkg);
            if (installedVersion !== requiredVersion) {
                toUpgrade.push({
                    pkg,
                    from: installedVersion !== null && installedVersion !== void 0 ? installedVersion : 'unknown',
                    to: requiredVersion,
                });
                toInstall.push(pkg);
            }
            else {
                alreadyInstalled.push(pkg);
            }
        }
        else {
            alreadyInstalled.push(pkg);
        }
    }
    // Log already installed packages
    for (const pkg of alreadyInstalled) {
        log_1.Log.info({ indent: false, logLevel }, `○ ${pkg} ${chalk_1.chalk.gray('(already installed)')}`);
    }
    // Log packages that will be upgraded
    for (const { pkg, from, to } of toUpgrade) {
        log_1.Log.info({ indent: false, logLevel }, `↑ ${pkg} ${chalk_1.chalk.yellow(`${from} → ${to}`)}`);
    }
    // If nothing to install, return early
    if (toInstall.length === 0) {
        return;
    }
    const installedRemotionPackages = list_of_remotion_packages_1.listOfRemotionPackages.filter((pkg) => allDeps.includes(pkg));
    // Get the version from the first installed Remotion package
    const packageJsonPath = `${remotionRoot}/node_modules/${installedRemotionPackages[0]}/package.json`;
    let targetVersion = null;
    if (installedRemotionPackages.length > 0) {
        try {
            const packageJson = require(packageJsonPath);
            targetVersion = packageJson.version;
            const packageList = toInstall.length === 1
                ? toInstall[0]
                : `${toInstall.length} packages (${toInstall.join(', ')})`;
            log_1.Log.info({ indent: false, logLevel }, `Installing ${packageList}`);
        }
        catch (err) {
            throw new Error(`Could not determine version of installed Remotion packages: ${err.message}`);
        }
    }
    else {
        // If no Remotion packages are installed, we can only install extra packages
        const notExtraPackages = toInstall.filter((pkg) => !extra_packages_1.EXTRA_PACKAGES[pkg]);
        if (notExtraPackages.length > 0) {
            throw new Error('No Remotion packages found in your project. Install Remotion first.');
        }
    }
    const manager = studio_server_1.StudioServerInternals.getPackageManager(remotionRoot, packageManager, 0);
    if (manager === 'unknown') {
        throw new Error(`No lockfile was found in your project (one of ${studio_server_1.StudioServerInternals.lockFilePaths
            .map((p) => p.path)
            .join(', ')}). Install dependencies using your favorite manager!`);
    }
    const packagesWithVersions = toInstall.map((pkg) => {
        if (extra_packages_1.EXTRA_PACKAGES[pkg]) {
            return `${pkg}@${extra_packages_1.EXTRA_PACKAGES[pkg]}`;
        }
        return `${pkg}@${targetVersion}`;
    });
    const command = studio_server_1.StudioServerInternals.getInstallCommand({
        manager: manager.manager,
        packages: packagesWithVersions,
        version: '',
        additionalArgs: args,
    });
    log_1.Log.info({ indent: false, logLevel }, chalk_1.chalk.gray(`$ ${manager.manager} ${command.join(' ')}`));
    const task = (0, node_child_process_1.spawn)(manager.manager, command, {
        env: {
            ...process.env,
            ADBLOCK: '1',
            DISABLE_OPENCOLLECTIVE: '1',
            npm_config_loglevel: 'error',
        },
        stdio: renderer_1.RenderInternals.isEqualOrBelowLogLevel(logLevel, 'info')
            ? 'inherit'
            : 'ignore',
    });
    await new Promise((resolve) => {
        task.on('close', (code) => {
            if (code === 0) {
                resolve();
            }
            else if (renderer_1.RenderInternals.isEqualOrBelowLogLevel(logLevel, 'info')) {
                throw new Error(`Failed to install packages, see logs above`);
            }
            else {
                throw new Error(`Failed to install packages, run with --log=info to see logs`);
            }
        });
    });
    const upgradedPkgs = new Set(toUpgrade.map((u) => u.pkg));
    for (const pkg of toInstall) {
        if (upgradedPkgs.has(pkg)) {
            // Already logged as upgrade
            continue;
        }
        if (extra_packages_1.EXTRA_PACKAGES[pkg]) {
            log_1.Log.info({ indent: false, logLevel }, `+ ${pkg}@${extra_packages_1.EXTRA_PACKAGES[pkg]}`);
        }
        else {
            log_1.Log.info({ indent: false, logLevel }, `+ ${pkg}@${targetVersion}`);
        }
    }
};
exports.addCommand = addCommand;
